# **Lab4主题：死锁**

## **死锁截图**
![Deadlock.png](https://github.com/TanTanJH/ES2016_14353278/blob/master/Deadlock.png)

## **死锁必要条件**
> * 1.互斥：一个资源每次只能被一个进程调用
> * 2.请求与保持：进程不会因为请求资源发生阻塞而释放已有的资源
> * 3.非抢占：进程已获得的资源在结束使用之前不能被抢占
> * 4.循环等待：若干进程之间形成的头尾相接的循环等待资源关系

## **死锁原因**
####1.首先终端窗口执行.bat文件，在for循环里调用Deadlock()函数
####2.Deadlock()内定义的线程t开始，立即执行run()函数里的b.methodB(a)，此时执行a.last()向A申请资源，成功则屏幕输出“Inside A.last()”
####3.自线程t开始等待count之后，a调用methodA函数，此时执行b.last()向B申请资源，成功则屏幕输出“Inside B.last()”
####4.而当a,b分别同时分别向B、A申请资源，此时由于函数被synchronized修饰，在已有线程访问的情况下，其它访问的线程被阻塞，所以两个线程出现线程饥饿死锁